# Peso Tracker Backend - Claude Context

## Project Overview

This is a **Weight Tracking API** built with NestJS, Prisma, and Supabase. The application allows users to track their weight progress over time with photos and goal management.

## Core Architecture

### Framework & Stack
- **Backend**: NestJS (Node.js framework)
- **Database**: PostgreSQL with Prisma ORM
- **File Storage**: Supabase Storage
- **Authentication**: JWT tokens
- **Image Processing**: Sharp (multiple sizes: thumbnail, medium, full)
- **Validation**: class-validator & class-transformer
- **Documentation**: Swagger/OpenAPI

### Development Environment
- **Local Database**: PostgreSQL running in Docker via Supabase CLI
- **Local Storage**: Supabase Storage (local instance)
- **Environment**: Development uses `.env.development` file
- **URLs**: 
  - API: http://localhost:3000
  - Swagger: http://localhost:3000/api
  - Supabase Studio: http://127.0.0.1:54323

## Database Schema & Business Rules

### Users Table
```prisma
model User {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  email     String   @unique
  password  String   // Bcrypt hashed
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  weights Weight[]
  goals   Goal[]
  photos  Photo[]
}
```

### Weights Table
```prisma
model Weight {
  id        Int      @id @default(autoincrement())
  userId    Int
  weight    Decimal  @db.Decimal(5, 1)  // Max 999.9 kg
  date      DateTime @db.Date
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User    @relation(fields: [userId], references: [id])
  photos Photo[]

  @@unique([userId, date])  // One weight per date per user
}
```

**Key Constraint**: Only ONE weight record per user per date.

### Photos Table
```prisma
model Photo {
  id          Int      @id @default(autoincrement())
  userId      Int
  weightId    Int      @unique  // One photo per weight
  notes       String?
  thumbnailUrl String   // 150x150px
  mediumUrl   String   // 400x400px
  fullUrl     String   // 800x800px
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  weight Weight @relation(fields: [weightId], references: [id])
}
```

**Key Constraint**: Only ONE photo per weight record (enforced at DB level).

### Goals Table
```prisma
model Goal {
  id               Int      @id @default(autoincrement())
  userId           Int
  targetWeight     Decimal  @db.Decimal(5, 1)
  targetDate       DateTime @db.Date
  type             String   @default("main")  // "main" or "milestone"
  isAutoGenerated  Boolean  @default(false)
  parentGoalId     Int?     // For hierarchical goals
  milestoneNumber  Int?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user       User  @relation(fields: [userId], references: [id])
  parentGoal Goal? @relation("GoalHierarchy", fields: [parentGoalId], references: [id])
  subGoals   Goal[] @relation("GoalHierarchy")
}
```

## API Endpoints Summary

### Authentication (Public)
- `POST /auth/register` - User registration
- `POST /auth/login` - User login

### Health Checks (Public)
- `GET /health` - General health status
- `GET /health/database` - Database connectivity
- `GET /health/supabase` - Supabase connectivity

### Weights (Protected)
- `POST /weights` - Create weight record
- `GET /weights` - List weights (with pagination & date filters)
- `GET /weights/:id` - Get specific weight
- `GET /weights/:id/photo` - Get photo for specific weight
- `PATCH /weights/:id` - Update weight
- `DELETE /weights/:id` - Delete weight

### Photos (Protected)
- `POST /photos/upload` - Upload photo (multipart/form-data)
- `GET /photos` - List photos (with pagination & weight filter)
- `GET /photos/:id` - Get specific photo
- `DELETE /photos/:id` - Delete photo

### Goals (Protected)
- `POST /goals` - Create goal
- `GET /goals` - List goals
- `GET /goals/:id` - Get specific goal
- `PATCH /goals/:id` - Update goal
- `DELETE /goals/:id` - Delete goal

## Key Business Logic

### Photo Management
1. **One Photo Per Weight**: Database constraint ensures integrity
2. **Multiple Sizes**: Automatic generation using Sharp
   - Thumbnail: 150x150px
   - Medium: 400x400px
   - Full: 800x800px
3. **Storage**: Supabase Storage with public URLs
4. **Path Structure**: `{userId}/{weightId}/{timestamp}_{size}.{ext}`

### Weight Tracking
1. **Date Uniqueness**: One weight per date per user
2. **Decimal Precision**: Weight stored as Decimal(5,1) for accuracy
3. **Photo Integration**: Weight records include associated photos
4. **Pagination**: Efficient data retrieval with page/limit

### Authentication & Security
1. **JWT Tokens**: Configurable expiration (default 24h)
2. **Route Protection**: All user data requires authentication
3. **User Isolation**: Users can only access their own data
4. **Password Security**: Bcrypt hashing with configurable rounds

## Common Development Patterns

### Error Handling
```typescript
// Standard error responses
throw new NotFoundException('Resource not found');
throw new ForbiddenException('Access denied');
throw new BadRequestException('Invalid input');
throw new ConflictException('Duplicate entry');
```

### Pagination Pattern
```typescript
async findAll(userId: number, page: number = 1, limit: number = 10) {
  const skip = (page - 1) * limit;
  
  const [data, total] = await Promise.all([
    this.prisma.model.findMany({ skip, take: limit }),
    this.prisma.model.count()
  ]);

  return {
    data,
    pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
  };
}
```

### Authentication Guard Usage
```typescript
@UseGuards(JwtAuthGuard)
@Controller('protected-resource')
export class ProtectedController {
  @Get()
  getData(@CurrentUser() user: { id: number }) {
    // user.id is automatically extracted from JWT
    return this.service.findByUserId(user.id);
  }
}
```

## File Structure

```
src/
├── auth/              # Authentication module
├── common/            # Shared decorators, guards, etc.
├── config/            # Configuration files
├── goals/             # Goal management
├── health/            # Health check endpoints
├── photos/            # Photo management
├── prisma/            # Prisma service
├── storage/           # Supabase storage service
├── weights/           # Weight tracking
├── app.module.ts      # Main app module
└── main.ts           # Application entry point

prisma/
└── schema.prisma     # Database schema

api-tests/            # Bruno API tests
└── Peso Tracker API/
```

## Environment Configuration

### Local Development
- Uses `.env.development` with local Supabase instance
- Database: PostgreSQL in Docker (port 54322)
- Storage: Local Supabase Storage (port 54321)
- No external dependencies required

### Production
- Uses `.env.production` with Supabase Cloud
- Real database and storage credentials required

## Development Workflow

### Setup Commands
```bash
npm install                    # Install dependencies
npx supabase start            # Start local Supabase
npx prisma migrate dev        # Apply migrations
npm run start:dev             # Start development server
```

### Common Tasks
```bash
npx prisma studio             # Database GUI
npx prisma migrate reset      # Reset database
npx prisma generate           # Regenerate Prisma client
npm run lint                  # Code linting
npm run format                # Code formatting
```

## Storage Configuration

### Bucket Setup
1. Bucket name: `peso-tracker-photos`
2. Public access: Enabled
3. File size limit: 5MB
4. Allowed types: `image/jpeg`, `image/png`, `image/webp`

### URL Structure
```
http://127.0.0.1:54321/storage/v1/object/public/peso-tracker-photos/{userId}/{weightId}/{timestamp}_{size}.{ext}
```

## Testing Strategy

### API Tests
- Bruno collections in `/api-tests/`
- Covers all endpoints with authentication
- Includes error scenarios and edge cases

### Unit Tests
- Service layer testing
- Mock external dependencies (Prisma, Supabase)
- Business logic validation

## Performance Considerations

### Database
- Indexes on foreign keys and unique constraints
- Pagination for large data sets
- Date-based filtering for weights

### Storage
- Multiple image sizes for different use cases
- Optimized JPEG compression (quality: 85)
- Efficient deletion with batch operations

### Caching
- No caching implemented yet (consider Redis for production)
- Potential areas: user sessions, frequent queries

## Security Measures

### Input Validation
- DTOs with class-validator decorators
- Automatic transformation and sanitization
- File type and size validation for uploads

### Rate Limiting
- Configurable per environment
- Development: 1000 requests per 5 minutes
- Production: Should be stricter

### CORS
- Configured for frontend URL
- Environment-specific settings

## Known Limitations & Future Improvements

### Current Limitations
1. No bulk operations for weights/photos
2. No advanced analytics or statistics
3. No data export functionality
4. No image optimization beyond size variants

### Potential Improvements
1. Add weight statistics and trend analysis
2. Implement data export (CSV, JSON)
3. Add weight prediction algorithms
4. Implement social features (sharing, comparisons)
5. Add notification system for goals
6. Implement backup/restore functionality

## Debugging Tips

### Common Issues
1. **Prisma Connection**: Check DATABASE_URL format
2. **Supabase Storage**: Ensure bucket exists and is public
3. **JWT Errors**: Verify JWT_SECRET matches between services
4. **File Upload**: Check file size limits and content types

### Useful Commands
```bash
# Check Supabase status
npx supabase status

# Reset local database
npx supabase db reset

# View logs
npx supabase logs

# Test database connection
npx prisma db pull
```

## Integration Points

### Frontend Integration
- JWT token in Authorization header
- Multipart form data for photo uploads
- Standard REST responses with consistent error format
- Swagger documentation for API reference

### Third-party Services
- Supabase: Database and storage
- Sharp: Image processing
- Prisma: Database ORM
- NestJS: Framework and ecosystem

This context should help you understand the application architecture, make informed decisions about modifications, and maintain consistency with existing patterns.